# -*- coding: utf-8 -*-
"""Copy of NeuralNetworksHousePriceRegression.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MNM2R2Ia7FkO_uWq4hcX-EBMN2RQC8gA
"""

"""
Dataset: https://www.cs.toronto.edu/~delve/data/boston/bostonDetail.html

Use the keras package and neural networks to build a regression model that predicts the prices of houses based on the characteristics of the house and its neighborhood.
"""

import matplotlib.pyplot as plt
from keras import Sequential
from keras.datasets import boston_housing
from keras.layers import Dense
from sklearn.preprocessing import StandardScaler

# ----------------------------- DATA LOADING -----------------------------
# Load Boston Housing dataset; Keras returns train/test splits out of the box.
# x_* are feature matrices (shape: [n_samples, 13]); y_* are target prices (MEDV).
(x_train, y_train), (x_test, y_test) = boston_housing.load_data()

# ----------------------------- SCALING ----------------------------------
# Standardize features: fit on train, apply same transform to test.
# Centering and scaling improve NN training stability and speed.
sc = StandardScaler()
x_train = sc.fit_transform(x_train)
x_test = sc.transform(x_test)

# ----------------------------- MODEL ------------------------------------
# Define a simple feedforward (Dense) regression network.
# input_dim=13 matches the number of feature columns in Boston Housing.
model = Sequential()
model.add(Dense(8, input_dim=13, activation="relu"))   # Hidden layer 1
model.add(Dense(16, activation="relu"))                # Hidden layer 2
model.add(Dense(1))                                    # Output: single continuous value (price)

# Compile with optimizer and loss/metrics for regression.
# "mse" = mean squared error (training objective), "mae" = mean absolute error (reporting metric).
model.compile(optimizer="rmsprop", loss="mse", metrics=["mae"])

# ----------------------------- TRAINING ---------------------------------
# Train the model for 100 epochs on the scaled training set.
# Returns a History object with per-epoch loss/metrics in history.history.
history = model.fit(x_train, y_train, epochs=100, verbose=0)

# ----------------------------- MONITORING -------------------------------
# Plot the mean absolute error (MAE) across epochs to inspect training dynamics.
plt.plot(history.history["mae"])
plt.xlabel("Epoch")
plt.ylabel("MAE")
plt.title("Training MAE")
plt.show()

# ----------------------------- EVALUATION -------------------------------
# Evaluate on the untouched test set.
# Returns [loss, mae] = [MSE on test, MAE on test].
model.evaluate(x_test, y_test, verbose=0)

# ----------------------------- PREDICTIONS ------------------------------
# Predict on test features, then compare true vs. predicted with a scatter plot.
y_pred = model.predict(x_test, verbose=0).flatten()
plt.scatter(y_test, y_pred)
plt.xlabel("True Values [MEDV]")
plt.ylabel("Predictions [MEDV]")
lims = [0, 50]
plt.plot(lims, lims)  # 45Â° reference line: perfect predictions would lie here.
plt.title("True vs Predicted MEDV (Test Set)")
plt.show()
